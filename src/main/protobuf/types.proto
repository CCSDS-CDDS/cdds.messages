syntax = "proto3";

package ccsds.cdds;

import "descriptor.proto";

// Extend MessageOptions with a custom string field
extend google.protobuf.MessageOptions {
  string oid = 50001;
}


/**
 * Denotes an aperture involved in service production (reception or transmission).
 */ 
message ApertureId {
  option (oid) = "1.2.840.10003.";

  oneof apertureIdForm {
    ObjectIdentifier globalForm = 1;  // The object identifier of the aperture / antenna as per SANA Service Site and Aperture registry
    string localForm = 2;             // A string to identify the aperture / antenna. Use a hex representation to encode octets
  } 
}

/**
 * Meta data of received data. Indicates which aperture or antenna
 * received data at a certain time and a data link continuity
 */
message ReceptionMetaData {

  /**
   * For a telemetry frame received on the data link layer, the receiveTime shall 
   * contain the UTC time at which the signal event corresponding to the leading
   * edge of the first bit of the Attached Sync Marker that immediately preceded
   * this encoded or un-coded frame was presented at the phase center of the
   * antenna used to acquire the frame.
   * For frames received somehow encapsulated, the receive time shall 
   * indicate the time of extraction.
   */
  DateTime receiveTime = 1;

  /**
   * The apertureId shall indicate which aperture or antenna
   * was used to acquire the frame.
   */
  ApertureId apertureId = 2;

  /**
   * The dataLinkContinuity shall indicate whether the extracted frame
   * is the direct successor of the previous frame
   * on the selected Master or Virtual Channel.
   * 
   * The dataLinkContinuity shall contain an integer value:
   *
   * If the gcvId is known for the service endpoint, the dataLinkContinuity is defined as follows:

   * A value of ‘-1’ indicates that this is the first frame after the start of
   * production or the selected channel is a Master Channel carrying AOS Transfer
   * Frames or USLP Transfer Frames and therefore no information regarding a
   * discontinuity on the channel can be provided. 
   */
  int64 dataLinkContinuity = 3;  
}

/**
 * An enum indicating the frame quality.
 */ 
enum FrameQuality {
    INVALID_FRAME_QUALITY = 0;  // not initialized
    GOOD = 1;                   // The frame decoded successfully
    ERRED = 2;                  // The frame is undecodable
    UNDETERMINED = 3;           // Frame decoding was not performed
}

/**
 * Date / Time definition for epoch 1958 with pico second precision
 */
message DateTime {
  uint32 days = 1;          // days since Jan 1st 1958 (01/01/1958 to 01/01/1970: 4383 days)
  uint32 msOfDay = 2;       // mill seconds of the day
  uint32 picoSecsOfMs = 3;  // sub pico seconds of the milliseconds
}

/**
 * An annotation composed out of a name and a value.
 */
message Annotation {
  string name = 1;          // The name of the annotation
  Value value = 2;          // The value of the annotation
}

/**
 * A value composed out of a particular type. For more details see https://protobuf.dev/programming-guides/proto3/#scalar
 */ 
message Value {
  oneof value {
    double doubleValue = 1;       // Double value. Uses IEEE 754 double-precision format
    float floatValue = 2;         // Float value. Uses IEEE 754 single-precision format
    int32 int32Value = 3;         // 32 bit signed int. Uses variable-length encoding
    uint32 uint32Value = 4;       // Unsigned 32 bit int. Uses variable-length encoding
    int64 int64Value = 5;         // 64 bit signed int 
    uint64 uint64Value = 6;       // 64 bit unsigned int 
    bool boolValue = 7;           // boolean (true/false)
    string stringValue = 8;       // A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 2^32
    bytes octetStringValue = 9;   // May contain any arbitrary sequence of bytes no longer than 2^32
  }  
}

/**
 * A qualified value has a value and is qualified to indicate validity and alarm states.
 */ 
message QualifiedValue {
  Value value = 1;                    // The value
  ValueQualifier valueQualifier = 2;  // The value qualifier indicating the validity
  AlarmQualifier alarmQualifier = 3;  // The alarm qualifier indicating alarms associated to the value
}

/**
 * A qualified value for encoded values. An encoded value (e.g. in Protobuf) must be encoded and decoded.
 */
message EncodedQualifiedValue {
  bytes encodedValue = 1;             // The value
  ValueQualifier valueQualifier = 2;  // The value qualifier indicating the validity
  AlarmQualifier alarmQualifier = 3;  // The alarm qualifier indicating alarms associated to the value
}

/**
 * A value qualifier qualifies values with respect to the validity of the value.
 */
enum ValueQualifier {
  INVALID_VALUE_QUALIFIER = 0;      // not initialized     
  VALID_VALUE = 1;                  // The value is valid
  UNKNOWN_VALUE = 2;                // The value is now known to the provider
  UNDEFINED_VALUE = 3;              // The value is in known to the provider, but not defined in the current context
}

/**
 * An enum to report on alarms and warnings
 */ 
enum Alarm {
  INVALID_ALARM = 0;           // not initialized 
  NO_ALARM = 1;                // No alarm present
  WARNING = 2;                 // A warning is present
  ALARM = 3;                   // An alarm is present 
}

message AlarmQualifier {
    
  /**
   * Indicates an alarm
   */
  Alarm alarm = 1; 

  /**
   * A generic optional reason code for alarms
   */
  optional int64 alarmReason = 2;

  /**
   * An optional message describing the alarm for operators
   */
  optional string alarmMessage = 3;
}

  /**
   * The state of the service production.
   * Note: CDDS Services can refine the meaning of the service production.
   */
  enum ProductionState {
    INVALID_PRODUCTION_STATE = 0;    // not initialized
    CONFIGURED = 1;                  // The service is configured but is not yet operational
    OPERATIONAL = 2;                 // The service is operating and functioning
    HALTED = 3;                      // The service has been halted by a management action
    INTERRUPTED = 4;                 // The service has encountered a fault and is interrupted
  }

  enum LockStatus {
    INVALID_LOCK_STATE = 0; // not initialized
    IN_LOCK = 1;            // In lock
    OUT_OF_LOCK = 2;        // Out of lock
    UNKNOWN_LOCK = 3;       // Unknown
  }

  /**
   * The Global Virtual Channel identifier
   */
  message GvcId {
    uint32 spacecraftId = 1;              // The spacecraft identifier (SCID)
    FrameVersion version = 2;             // The transfer frame version as per USLP, AOS or packet TM
    optional uint32 virtualChannelId = 3; // optional, if omitted this is a master channel
  }
  
  /**
   * A list of Global Virtual Channel Identifiers.
   */
  message GvcIdList {
      repeated GvcId gvcId = 1; // Global Virtual Channel Identifiers 
  }

  /**
   * The frame version corresponding to the CCSDS frame versions.
   */
  enum FrameVersion {
    TM_TC_SDLP = 0;             // 0: CCSDS 132.0 TM Space Data Link Protocol or CCSDS 232.0 TC Space Data Link Protocol
    AOS = 1;                    // 1: CCSDS 732.0 AOS Space Data Link Protocol
    USLP = 2;                   // 2: CCSDS 732.1 USLP Space Data Link Protocol
    UNKNOWN = 3;                // Unknown frame version (non CCSDS)     
  }

  /**
   * An Object Identifier
   */ 
  message ObjectIdentifier {

    /**
     * An optional OID string in dotted notation.
     * Example: 1.2.3.4.5
     */
    string oidString = 1;

    /**
     * The sequence of numbers representing the 
     * Object Identifier
     */
    repeated uint64 arcs = 2;
  }

  /**
   * The QoS for data exchange.
   */
  message QoS {
      EnumQoS qos = 1;    // The QoS value
  }  

  /**
   * The Quality of Service definition governs the message delivery 
   */
  enum EnumQoS {
    INVALID_QOS = 0;        // not initialized
    AT_MOST_ONCE = 1;       // Data shall be delivered 0..1 time
    AT_LEAST_ONCE = 2;      // Data shall be delivered at least once, but potentially more often
    EXACTLY_ONCE = 4;       // Data shall be delivered exactly once
  }

  /**
   * Used for gRPC methods without argument
   */
  message NoArg {}